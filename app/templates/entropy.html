<!DOCTYPE html>
<html lang="ru" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Главная / Сбор Энтропии - VeriRandom</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <link href="/static/css/custom.css" rel="stylesheet">
    <style>
        /* Общие стили для фона и текста */
        body {
            background: #0d1117; /* Основной темно-черный фон */
            color: #e2e8f0;
        }

        /* Панель с контентом: теперь с темно-черным фоном */
        .panel {
            background-color: #0d1117; /* Темно-черный, как и основной фон */
            border: 1px solid #ffc107; /* Желтая рамка (warning) */
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.2); /* Желтое свечение */
            border-radius: 12px;
        }

        /* Область вывода данных (Code block style) */
        .data-output {
            height: 300px;
            overflow-y: scroll;
            padding: 12px;
            border: 1px solid #334155; /* Темная рамка */
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9rem;
            font-family: monospace;
            background-color: #000000; /* Чисто черный фон для кода */
            border-radius: 6px;
        }

        /* Статус-бар */
        .status-bar {
            background-color: #161b22; /* Немного светлее, чтобы создать легкий контраст со страницами */
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid #334155; /* Темная рамка */
        }

        /* Визуальный акцент для энтропии */
        .entropy-bits {
            color: #34d399 !important; /* Success Green */
            font-weight: bold;
        }

        /* Стили для Canvas */
        #canvas-output {
            border: 1px solid #ffc107; /* Желтая рамка */
            background-color: #000000;
        }
    </style>
</head>
<body class="bg-black text-white">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark border-bottom border-warning">
        <div class="container">
            <a class="navbar-brand fw-bold text-warning fs-3 me-5" href="/">
                VeriRandom
            </a>
            <button class="navbar-toggler border-warning" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto align-items-center">
                    <li class="nav-item">
                        <a class="nav-link nav-glow" href="/">Главная</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link nav-glow" href="/lottery">Проведение тиража</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link nav-glow" href="/audit">Аудит генератора</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link nav-glow" href="/demo">Демонстрация</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link nav-glow" href="/guide">Руководство</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link nav-glow text-white" href="/entropy">Сбор</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container py-5">
        <div class="row mb-4">
            <div class="col text-center">
                <h1 class="text-warning mb-3">
                    <i class="bi bi-cpu-fill text-warning"></i> генератор энтропии
                </h1>
                <p class="lead text-white-50">
                    Сбор **экзотической энтропии** из браузера (GPU/CPU timing jitter) и отправка на сервер для усиления.
                </p>
            </div>
        </div>

        <div class="bg-dark status-bar d-flex justify-content-between flex-wrap text-white-50">
            <div class="d-flex flex-column me-4 mb-2 mb-md-0">
                <span class="text-light">Статус: <strong id="status" class="text-warning">Инициализация...</strong></span>
                <span class="small">Последний джиттер (мс): <strong id="last-jitter" class="text-warning">0.0000</strong></span>
            </div>
            <div class="d-flex flex-column me-4 mb-2 mb-md-0">
                <span class="text-light">Собрано байт: <strong id="byte-count" class="entropy-bits">0</strong></span>
            </div>
            <div class="d-flex flex-column">
                <span class="text-light">Отправлено пакетов: <strong id="sent-count" class="entropy-bits">0</strong></span>
            </div>
        </div>

        <div class="bg-dark row g-4">
            <div class="col-lg-6">
                <div class="bg-dark panel p-4 h-100">
                    <h4 class="text-warning mb-3">1. Визуальный Хаос (GPU Jitter)</h4>
                    <p class="text-white-50 small">
                        Canvas-рендеринг, зависимый от нестабильности GPU, VSync и драйверов.
                    </p>
                    <canvas id="canvas-output" width="400" height="200" class="w-100"></canvas>
                </div>
            </div>

            <div class="bg-dark col-lg-6">
                <div class="bg-dark panel p-4 h-100">
                    <h4 class="text-warning mb-3">2. Цифровой Хаос (CPU Jitter)</h4>
                    <p class="text-white-50 small">
                        Логистическое отображение:
                        <code class="text-warning small">x<sub>n+1</sub> = r * x<sub>n</sub> * (1 - x<sub>n</sub>)</code>
                    </p>
                    <div class="data-output" id="logistic-output">Ожидание данных...</div>
                </div>
            </div>
        </div>

        <div class="bg-dark row mt-4">
            <div class="col-12">
                <div class="bg-dark panel p-4">
                    <h4 class="text-warning mb-3">Сырая энтропия (Последние пакеты HEX)</h4>
                    <div class="data-output" id="entropy-output" style="height: 150px;">Ожидание сбора...</div>
                    <button class="btn btn-success mt-3" onclick="clearAndRestart()">
                        <i class="bi bi-arrow-clockwise me-2"></i> Очистить и перезапустить
                    </button>
                </div>
            </div>
        </div>

<div class="card bg-dark border-warning p-4 mt-5">
    <h5 class="text-warning mb-3">
        <i class="bi bi-file-earmark-code-fill me-2"></i> Инструменты для NIST/Dieharder
    </h5>
    <p class="small text-white-50">
        Создание криптографически стойкого файла с **1 000 000 бинарных значений (0 и 1)**, посеянного из текущего пула энтропии, для независимой загрузки в сторонние статистические тесты.
    </p>
    <button class="btn btn-outline-warning w-100 mt-2" onclick="downloadNISTData()">
        <i class="bi bi-download me-2"></i> Сгенерировать и скачать файл (1 млн бит)
    </button>
</div>
    </div>

    <footer class="bg-dark text-warning mt-5">
        <div class="container py-4">
            <p class="text-white mb-0 text-center">
                &copy; 2024 VeriRandom. Сбор энтропии активен.
            </p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const canvas = document.getElementById('canvas-output');
        const ctx = canvas.getContext('2d');
        const logisticOutput = document.getElementById('logistic-output');
        const entropyOutput = document.getElementById('entropy-output');
        const statusEl = document.getElementById('status');
        const byteCountEl = document.getElementById('byte-count');
        const lastJitterEl = document.getElementById('last-jitter');
        const sentCountEl = document.getElementById('sent-count');

        let entropyBytes = [];
        let frameCount = 0;
        let lastCanvasTime = performance.now();
        let lastLogisticTime = performance.now();
        let animationFrameId = null;
        let collecting = true;
        let sentPackets = 0;

        // Инициализация хаотического отображения
        let x_n = (performance.now() * 1000000) % 1; // дробная часть → [0,1)
        const r = 3.9999;

        // --- GPU Jitter (Canvas) ---
        function renderChaos() {
            if (!collecting) return;

            const w = canvas.width;
            const h = canvas.height;
            const t = performance.now() * 0.001;

            const imageData = ctx.createImageData(w, h);
            const data = imageData.data;
            const maxVal = 255; // Максимальное значение цвета

            // Простой шум, зависящий от времени t и координат (x, y)
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                const x = idx % w;
                const y = Math.floor(idx / w);

                // Генерируем "хаотичное" значение цвета
                const noise = Math.sin(x * 0.1 + t * 5) * Math.cos(y * 0.05 + t * 3) * 128 + 128;

                data[i]     = noise % maxVal;       // R
                data[i + 1] = (noise + 50) % maxVal; // G
                data[i + 2] = (noise + 100) % maxVal; // B
                data[i + 3] = maxVal; // Alpha
            }
            ctx.putImageData(imageData, 0, 0);

            const now = performance.now();
            const jitter = now - lastCanvasTime; // Джиттер в миллисекундах
            lastCanvasTime = now;

            collectEntropy(jitter, 'canvas');
            animationFrameId = requestAnimationFrame(renderChaos);
        }

        // --- CPU Jitter (Logistic Map) ---
        async function runLogisticLoop() {
            while (collecting) {
                const iterations = 30000;
                let sum = 0;
                for (let i = 0; i < iterations; i++) {
                    x_n = r * x_n * (1 - x_n);
                    sum += x_n;
                }

                if (frameCount % 20 === 0) {
                    logisticOutput.textContent =
                        `Среднее: ${ (sum / iterations).toFixed(10) }\n` +
                        `x_n: ${x_n.toExponential(10)}\n\n` +
                        logisticOutput.textContent.split('\n').slice(0, 6).join('\n');
                }

                const now = performance.now();
                const jitter = now - lastLogisticTime; // Джиттер в миллисекундах
                lastLogisticTime = now;

                collectEntropy(jitter, 'logistic');
                frameCount++;

                // Используем небольшой таймаут для управления циклом и предотвращения блокировки
                await new Promise(r => setTimeout(r, 7));
            }
        }

        // --- Jitter to Entropy ---
        function collectEntropy(timeDeltaMs, source) {
            // Преобразуем мс в мкс для более точного джиттера
            const microSec = timeDeltaMs * 1000;

            // Источник A: целая часть мкс (планировщик ОС)
            const intNoise = Math.floor(microSec);

            // Источник B: дробная часть мкс (аппаратный шум)
            const fractionalPart = microSec - intNoise;
            const fracNoise = Math.floor(fractionalPart * 10000000); // 7 знаков

            // Источник C: системное время (независимый таймер)
            const timeNoise = Math.floor(performance.now() * 10000);

            // Комбинируем три источника через XOR → младший байт
            const byte = (intNoise ^ fracNoise ^ timeNoise) & 0xFF;
            entropyBytes.push(byte);

            byteCountEl.textContent = entropyBytes.length;

            // Обновляем UI каждые 64 байта
            if (entropyBytes.length % 64 === 0) {
                const hex = entropyBytes.slice(-64).map(b => b.toString(16).padStart(2, '0')).join(' ');
                entropyOutput.textContent = hex + '\n' + entropyOutput.textContent;
                lastJitterEl.textContent = timeDeltaMs.toFixed(4);
            }

            statusEl.textContent = `Сбор активен (${source})`;

            // Отправляем пакет каждые 256 байт
            if (entropyBytes.length >= 256) {
                sendEntropyBatch();
            }
        }

        // --- Server Communication ---
        async function sendEntropyBatch() {
            const batch = entropyBytes.splice(0, 256); // Извлекаем 256 байт

            try {
                const response = await fetch('/entropy/feed', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ raw: batch, source: 'browser-jitter' })
                });

                if (response.ok) {
                    sentPackets++;
                    sentCountEl.textContent = sentPackets;
                    statusEl.textContent = 'Отправлено 256 байт!';
                    statusEl.classList.remove('text-danger');
                    statusEl.classList.add('text-warning');
                } else {
                    const errorData = await response.json().catch(() => ({ detail: `Ошибка сервера: ${response.status}` }));
                    statusEl.textContent = `Ошибка отправки: ${errorData.detail || response.status}`;
                    statusEl.classList.remove('text-warning');
                    statusEl.classList.add('text-danger');
                }
            } catch (e) {
                statusEl.textContent = 'Сетевая ошибка: ' + e.message;
                statusEl.classList.remove('text-warning');
                statusEl.classList.add('text-danger');
            }
        }

        // --- Control Functions ---
        function startCollection() {
            collecting = true;
            lastCanvasTime = performance.now();
            lastLogisticTime = performance.now();

            animationFrameId = requestAnimationFrame(renderChaos);
            runLogisticLoop().catch(console.error);

            statusEl.textContent = 'Сбор активен';
            statusEl.classList.remove('text-danger');
            statusEl.classList.add('text-warning');
        }

        function clearAndRestart() {
            collecting = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            entropyBytes = [];
            byteCountEl.textContent = '0';
            entropyOutput.textContent = 'Очищено. Перезапуск...';
            logisticOutput.textContent = 'Ожидание данных...';
            sentPackets = 0;
            sentCountEl.textContent = '0';

            statusEl.textContent = 'Перезапуск...';

            // Небольшая задержка перед стартом
            setTimeout(startCollection, 200);
        }

        // Запуск при загрузке страницы
        window.addEventListener('load', startCollection);

        async function downloadNISTData() {
    const btn = document.querySelector('.btn-outline-warning');
    const originalText = btn.innerHTML;

    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span> Генерация...';

    try {
        // !!! ЭТОТ ЭНДПОИНТ НУЖНО РЕАЛИЗОВАТЬ НА БЭКЕНДЕ !!!
        const response = await fetch('/api/generate_nist_data', {
            method: 'POST', // Используем POST, чтобы показать, что это действие
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ length: 1000000 }) // Запрашиваем 1 миллион бит
        });

        if (!response.ok) {
            throw new Error(`Ошибка сервера: ${response.status}`);
        }

        // Получаем файл/данные и инициируем скачивание
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `verirandom_nist_data_${new Date().toISOString().slice(0, 10)}.txt`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);

    } catch (error) {
        console.error('Ошибка генерации NIST файла:', error);
        alert('Ошибка при генерации файла: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
}
    </script>
</body>
</html>